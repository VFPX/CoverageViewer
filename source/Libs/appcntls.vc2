*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="appcntls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS lingraytop AS zline OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata
	*</DefinedPropArrayMethod>

	BorderColor = 128,128,128
	Height = 0
	Name = "lingraytop"
	Width = 300
	_memberdata = <VFPData>
		<memberdata name="bordercolor" display="BorderColor"/>
		<memberdata name="height" display="Height"/>
		<memberdata name="width" display="Width"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS linwhitebott AS zline OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata
	*</DefinedPropArrayMethod>

	BorderColor = 255,255,255
	Height = 0
	Name = "linwhitebott"
	Width = 300
	_memberdata = <VFPData>
		<memberdata name="bordercolor" display="BorderColor"/>
		<memberdata name="width" display="Width"/>
		<memberdata name="height" display="Height"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS y3dline AS zcontainer OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lingraytop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Linwhitebott" UniqueID="" Timestamp="" />

	Height = 2
	Name = "y3dline"
	Width = 300
	_memberdata = <VFPData>
		<memberdata name="height" display="Height"/>
		<memberdata name="width" display="Width"/>
		</VFPData>

	ADD OBJECT 'Lingraytop' AS lingraytop WITH ;
		Left = 0, ;
		Name = "Lingraytop", ;
		Top = 0
		*< END OBJECT: ClassLib="appcntls.vcx" BaseClass="line" />

	ADD OBJECT 'Linwhitebott' AS linwhitebott WITH ;
		Left = 0, ;
		Name = "Linwhitebott", ;
		Top = 1
		*< END OBJECT: ClassLib="appcntls.vcx" BaseClass="line" />
	
	PROCEDURE Init
		IF NOT DODEFAULT()
		    RETURN .F.
		ENDIF
		THIS.Resize()
		RETURN .T.
	ENDPROC

	PROCEDURE Resize
		THIS.linGrayTop.Width = THIS.Width
		THIS.linWhiteBott.Width = THIS.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ycmdbutton AS zbutton OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: clickaction		&& Put your Click() event code here
		*m: setnextfocus		&& Set the focus to THIS.SetFocusToCntl
		*p: csetfocus2cntl		&& Sets focus to this control (if not empty) after button is clicked
	*</DefinedPropArrayMethod>

	csetfocus2cntl = 		&& Sets focus to this control (if not empty) after button is clicked
	Name = "ycmedbutton"
	_memberdata = <VFPData>
		<memberdata name="csetfocus2cntl" display="cSetFocus2Cntl"/>
		<memberdata name="clickaction" display="ClickAction"/>
		<memberdata name="setnextfocus" display="SetNextFocus"/>
		</VFPData>
	
	PROCEDURE Click
		* WARNING: Don't change this method.  Instead, put Click() actions into
		*           the ClickAction() method.
		
		* Don't let an anxious user click too many times
		THIS.Enabled = .F.
		
		* Do our click action
		THIS.ClickAction()
		
		* Put us back in business
		THIS.Enabled = .T.
	ENDPROC

	PROCEDURE clickaction		&& Put your Click() event code here
		* Place for code for Click() events -- NOT in Click() - see that method
		*    for the reason.
		
		* Return .T. if we're to set the focus to the next control (if anything's
		*    in THIS.cSetFocusToCntl); else, return .F.
		RETURN .T.
	ENDPROC

	PROCEDURE setnextfocus		&& Set the focus to THIS.SetFocusToCntl
		LOCAL cCntl, oCntl
		IF NOT EMPTY(THIS.cSetFocusToCntl)
		    cCntl = THIS.cSetFocusToCntl
		    oCntl = &cCntl
		    IF PEMSTATUS(oCntl, 'SetFocus', 5)
		        oCntl.SetFocus()
		    ENDIF
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS yeditbox AS zeditbox OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setbgcolor		&& Set our B/G color as appropriate
	*</DefinedPropArrayMethod>

	IntegralHeight = .T.
	Name = "yeditbox"
	SelectedBackColor = 0,0,128
	Width = 185
	_memberdata = <VFPData>
		<memberdata name="selectedbackcolor" display="SelectedBackColor"/>
		<memberdata name="setbgcolor" display="SetBGColor"/>
		</VFPData>
	
	PROCEDURE setbgcolor		&& Set our B/G color as appropriate
		LPARAMETERS cType
		DO CASE
		CASE cType = 'E'
		    THIS.BackColor = RGB(255,210,210)       && Error Color
		CASE cType = 'W'
		    THIS.BackColor = RGB(255,255,190)       && Warning Color
		OTHERWISE
		    THIS.BackColor = RGB(255,255,255)       && Normal Color
		ENDCASE
	ENDPROC

ENDDEFINE

DEFINE CLASS ylookupbtn AS ycmdbutton OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = ""
	DownPicture = ..\pix\lookup.bmp
	Height = 23
	Name = "ylookupbtn"
	Picture = ..\pix\lookup.bmp
	Width = 24
	_memberdata = <VFPData>
		<memberdata name="width" display="Width"/>
		<memberdata name="height" display="Height"/>
		</VFPData>

ENDDEFINE

DEFINE CLASS yprocnotes AS yeditbox OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\inc\appincl.h"
	*<DefinedPropArrayMethod>
		*m: addmsg2ra		&& Add the passed message to our array object
		*m: changemsgline		&& Change an already displayed message line by appending text or replacing the entire line
		*m: chglastline		&& Replace the last line of the displayed value
		*m: clearpermlines		&& Mark some or all permanent lines as now being disposable
		*m: displaymsg		&& Add a new message to the current display
		*m: displaynumber		&& Add a number to a line or change a currently displayed number
		*m: displayra		&& Put the contents of THIS.oMsgs into our display
		*m: showeditboxtestsample		&& Displays a string of column and row numbers (use for design only)
		*p: cnumbline		&& Message line (without number) for line that ends with a changing number
		*p: ndispcols		&& The number of columns (characters) we can display in this editbox. MUST SET AT DESIGN TIME.
		*p: ndisprows		&& The number of rows we can display in this editbox. MUST SET AT DESIGN TIME.
		*p: nnumbposn		&& The horizontal position of the current numeric display
		*p: omsgs		&& Array object for messages
	*</DefinedPropArrayMethod>

	cnumbline = 		&& Message line (without number) for line that ends with a changing number
	DisabledBackColor = 255,255,255
	DisabledForeColor = 64,0,64
	Height = 128
	IntegralHeight = .T.
	Name = "yprocnotes"
	ndispcols = 0		&& The number of columns (characters) we can display in this editbox. MUST SET AT DESIGN TIME.
	ndisprows = 0		&& The number of rows we can display in this editbox. MUST SET AT DESIGN TIME.
	nnumbposn = 0		&& The horizontal position of the current numeric display
	omsgs = .NULL.		&& Array object for messages
	ReadOnly = .T.
	ScrollBars = 0
	Value = ([1] + chr(13) + [2] + chr(13) + [3] + chr(13) + [4] + chr(13) + [5] + chr(13) + [6] + chr(13) + [7] + chr(13) + [8] + chr(13))
	Width = 175
	_memberdata = <VFPData>
		<memberdata name="showeditboxtestsample" type="method" display="ShowEditBoxTestSample"/>
		<memberdata name="chglastline" type="method" display="ChgLastLine"/>
		</VFPData>
	
	PROTECTED PROCEDURE addmsg2ra		&& Add the passed message to our array object
		LPARAMETERS cTheMsg, bLdgCR, bPerm
		LOCAL cThisMsg, bGotMore, nLeftMarg, nSplitAt, cDispStr, oExcess, nX, ;
		  cCurrLine, cOneLine
		
		* Our array already has the current value on the screen.  Generally,
		*   cTheMsg will be added to the last row.  But, if we're to add a
		*   leading CR_LF, create a new, blank row.
		IF bLdgCR OR THIS.oMsgs.nRows = 0
		    THIS.oMsgs.AddRow('', .F.)
		ENDIF
		
		* Convert any CR_LFs to 0FFhs
		cThisMsg = cTheMsg
		IF CR_LF $ cTheMsg
		    cThisMsg = STRTRAN( cTheMsg, CR_LF, HEX_FF)
		ENDIF
		
		* If the line is too long break it up by inserting CR_LFs
		bGotMore = .F.
		DO CASE
		CASE LEN(cThisMsg) > THIS.nDispCols
		    bGotMore = .T.
		
		    * First, what's the left margin? (we'll add one for subsequent
		    *   lines)
		    nLeftMarg = ( LEN(cThisMsg) - LEN( LTRIM(cThisMsg)) )
		
		    * Split the string at THIS.nDispCols-nLeftMarg characters
		    nSplitAt = THIS.nDispCols - nLeftMarg
		
		    * Extract the 1st line
		    cDispStr = cThisMsg
		    cThisMsg = goStr.SplitString(@cDispStr, nSplitAt)
		
		    * Now, the remainder will be put into a memo array, but we'll want
		    *   to add the left margin and a 1 char. indent, so allow room for
		    *   those.
		    oExcess = CREATEOBJECT('MemoArray', cDispStr, nSplitAt-1 )
		
		    * Add the margin and 1-char indent to each of these
		    WITH oExcess
		        FOR nX = 1 TO .nRows
		            .aRA[nX,1] = SPACE(nLeftMarg + 1) + .aRA[nX,1]
		        ENDFOR
		    ENDWITH
		
		* Also break it up if there are any internal CR_LFs
		CASE HEX_FF $ cThisMsg
		    bGotMore = .T.
		
		    * Extract the 1st line
		    cDispStr = cThisMsg
		    cThisMsg = goStr.ExtrToken(@cDispStr, HEX_FF)
		
		    * Here, we have no fancy splitting
		    oExcess = CREATEOBJECT('MemoArray', cDispStr, THIS.nDispCols )
		ENDCASE
		
		* Add the first line to the current array line and mark it as bPerm.
		cCurrLine = THIS.oMsgs.aRA[THIS.oMsgs.nRows, 1]
		THIS.oMsgs.aRA[THIS.oMsgs.nRows, 1] = cCurrLine + cThisMsg
		IF bPerm
		    THIS.oMsgs.aRA[THIS.oMsgs.nRows, 2] = .T.
		ENDIF
		
		* Handle any remaining message lines, but ignore bPerm.
		IF bGotMore
		    WITH oExcess
		        FOR nX = 1 TO .nRows
		            cOneLine = .aRA[nX,1]
		            THIS.oMsgs.AddRow(cOneLine, .F.)
		        ENDFOR
		    ENDWITH
		ENDIF
	ENDPROC

	PROCEDURE changemsgline		&& Change an already displayed message line by appending text or replacing the entire line
		LPARAMETERS cMsgStart, cNewLine, bAddIt
		LOCAL bChangedIt, nRow
		
		* We're to search for cMsgStart in our array.  If we find it, change
		*   the entire line to cNewLine or, if bAddIt append the string at the end.
		bChangedIt = .F.
		WITH THIS.oMsgs
		    nRow = .Locate(cMsgStart, 1)
		    IF nRow > 0
		        IF bAddIt
		            .aRA[nRow,1] = .aRA[nRow,1] + cNewLine
		        ELSE
		            .aRA[nRow,1] = cNewLine
		        ENDIF
		        bChangedIt = .T.
		    ENDIF
		ENDWITH
		
		* Display our array and we're done
		THIS.DisplayRa()
		
		* Return .T. if we found and changed it.
		RETURN bChangedIt
	ENDPROC

	PROCEDURE chglastline		&& Replace the last line of the displayed value
		LPARAMETERS cNewLine
		LOCAL nLastRow, cLastLine, cDispStr, nPosn
		
		* Get the last line from oMsgs
		*    oMsgs.aRA[x,1] - Display line
		*    oMsgs.aRA[x,2] - .T. if permanent line
		WITH THIS
		    nLastRow  = THIS.oMsgs.nRows
		    cLastLine = .oMsgs.aRA[nLastRow, 1]
		
		    * Change that in the array
		    .oMsgs.aRA[nLastRow, 1] = cNewLine
		
		    * ...and in the text
		    cDispStr = .Value
		    nPosn = RAT(cLastLine, cDispStr)
		    cDispStr = LEFT(cDispStr, nPosn-1) + cNewLine
		
		    * Make this the new value
		    .ReadOnly = .F.
		    .Value = cDispStr
		    .ReadOnly = .T.
		ENDWITH
	ENDPROC

	PROCEDURE clearpermlines		&& Mark some or all permanent lines as now being disposable
		LPARAMETERS nNumb2Keep
		LOCAL nKeep, nW
		
		* How many permanent lines are we to keep (default = 0)
		nKeep = 0
		IF VARTYPE(nNumb2Keep) = 'N' AND nNumb2Keep > 1
		    nKeep = nNumb2Keep
		ENDIF
		
		* Array object structure:
		*   oMsgs.aRA[x,1] - Display line
		*   oMsgs.aRA[x,2] - .T. if permanent
		WITH THIS.oMsgs
		    FOR nW = 1 TO .nRows
		        IF .aRA[nW,2]
		            IF nW > nKeep
		                .aRA[nW,2] = .F.
		            ENDIF
		        ENDIF
		    ENDFOR
		ENDWITH
		
		* This will take effect the next time the display is updated
		RETURN nKeep
	ENDPROC

	PROCEDURE displaymsg		&& Add a new message to the current display
		LPARAMETERS cTheMsg, bLdgCR, bPerm
		LOCAL nX
		
		* Add the new message to our array object
		THIS.AddMsg2Ra(cTheMsg, bLdgCR, bPerm)
		
		* Toss any non-permanent lines if we have too many rows
		WITH THIS.oMsgs
		    DO WHILE .nRows > THIS.nDispRows
		        FOR nX = 1 TO .nRows
		
		            * Toss a non-permanent row
		            IF NOT .aRA[nX,2]
		                .DeleteRow(nX)
		                EXIT
		            ENDIF
		        ENDFOR
		    ENDDO
		ENDWITH
		
		* Display our array in the editbox
		THIS.DisplayRa()
		
		* As we added a message, clear any number display settings
		THIS.nNumbPosn = -1
		THIS.cNumbLine = ''
		RETURN .T.
	ENDPROC

	PROCEDURE displaynumber		&& Add a number to a line or change a currently displayed number
		LPARAMETERS xNumber
		LOCAL cValue, nPosn, cDispStr, nRAPosn, cNumb
		
		* Numbers are always displayed at the very end of the text.  But,
		*   where is the number to be placed.  Define that and get the
		*   text without any number
		WITH THIS
		    cValue = .Value
		    IF .nNumbPosn = -1
		        nPosn = LEN(cValue)
		        .nNumbPosn = nPosn
		        cDispStr = cValue
		        .cNumbLine = .oMsgs.aRA[THIS.oMsgs.nRows, 1]
		    ELSE
		        nPosn = .nNumbPosn
		        nRAPosn = LEN(cValue) - nPosn
		        cDispStr = LEFT(cValue, nPosn)
		    ENDIF
		
		    * The passed number could be either a string or a number
		    IF VARTYPE(xNumber) = 'N'
		        cNumb = LTRIM( STR(xNumber) )
		    ELSE
		        cNumb = xNumber
		    ENDIF
		
		    * Add the number to the line and array line
		    cDispStr = cDispStr + cNumb
		    .oMsgs.aRA[THIS.oMsgs.nRows, 1] = .cNumbLine + cNumb
		
		    * Make this the new value
		    .ReadOnly = .F.
		    .Value = cDispStr
		    .ReadOnly = .T.
		ENDWITH
	ENDPROC

	PROTECTED PROCEDURE displayra		&& Put the contents of THIS.oMsgs into our display
		LOCAL cDispStr, nX
		
		* Convert the array into a displayable string
		cDispStr = ''
		WITH THIS.oMsgs
		    FOR nX = 1 TO .nRows
		        cDispStr = cDispStr + .aRA[nX,1]
		
		        * Add a CR_LF except for the last row
		        IF nX < .nRows
		            cDispStr = cDispStr + CR_LF
		        ENDIF
		    ENDFOR
		ENDWITH
		
		* Put the string
		WITH THIS
		    .ReadOnly = .F.
		    .Value = cDispStr
		    .ReadOnly = .T.
		ENDWITH
	ENDPROC

	PROCEDURE Init
		IF NOT DODEFAULT()
		    RETURN .F.
		ENDIF
		
		* Add our message array object:
		*    oMsgs.aRA[x,1] - Display line
		*    oMsgs.aRA[x,2] - .T. if permanent line
		THIS.oMsgs = CREATEOBJECT('ArrayObj', 2)
		
		* Finally, clear our value and make sure we're ReadOnly
		THIS.Value = ''
		THIS.ReadOnly = .T.
		
		* Done
		RETURN .T.
	ENDPROC

	PROCEDURE showeditboxtestsample		&& Displays a string of column and row numbers (use for design only)
		LOCAL cLine1, cLine2, nCols
		cLine1 = [1234567890123456789012345678901234567890123456789012345] + ;
		  [67890123456789012345678901234567890]
		cLine2 = [         1         2         3         4         5         6      ] + ;
		  [   7         8         9]
		nCols = THIS.nDispCols
		IF nCols > 0
		    cLine1 = LEFT(cLine1, nCols)
		    cLine2 = LEFT(cLine2, nCols)
		ENDIF
		THIS.Value = cLine1 + CR_LF + ;
		  cLine2 + CR_LF + ;
		  [Line 3] + CR_LF + ;
		  [Line 4] + CR_LF + ;
		  [Line 5] + CR_LF + ;
		  [Line 6] + CR_LF + ;
		  [Line 7] + CR_LF + ;
		  [Line 8] + CR_LF + ;
		  [Line 9] + CR_LF + ;
		  [Line 10] + CR_LF + ;
		  [Line 11] + CR_LF + ;
		  [Line 12] + CR_LF + ;
		  [Line 13] + CR_LF + ;
		  [Line 14] + CR_LF + ;
		  [Line 15] + CR_LF + ;
		  [Line 16] + CR_LF + ;
		  [Line 17] + CR_LF + ;
		  [Line 18] + CR_LF + ;
		  [Line 19] + CR_LF + ;
		  [Line 20] + CR_LF + ;
		  [Line 21] + CR_LF + ;
		  [Line 22] + CR_LF + ;
		  [Line 23] + CR_LF + ;
		  [Line 24] + CR_LF + ;
		  [Line 25] + CR_LF + ;
		  [Line 26] + CR_LF + ;
		  [Line 27] + CR_LF + ;
		  [Line 28] + CR_LF + ;
		  [Line 29] + CR_LF + ;
		  [Line 30]
	ENDPROC

ENDDEFINE

DEFINE CLASS ytextbox AS ztextbox OF "appcntls.vcx" 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setbgcolor		&& Sets the B/G color for "E"rror, "W"arning or "N" ormal (the default)
		*m: showerrormsg		&& Display our error message
		*p: bentryisok		&& .T. if entry has passed validation
		*p: bitchanged		&& .T. if entry has changed since last Valid()
		*p: cerrormsg		&& Error message for current entry (if any)
	*</DefinedPropArrayMethod>

	bentryisok = .F.		&& .T. if entry has passed validation
	bitchanged = .F.		&& .T. if entry has changed since last Valid()
	cerrormsg = 		&& Error message for current entry (if any)
	Name = "ytextbox"
	_memberdata = <VFPData>
		<memberdata name="setbgcolor" display="SetBGColor"/>
		<memberdata name="bentryisok" display="bEntryIsOK"/>
		<memberdata name="cerrormsg" display="cErrorMsg"/>
		</VFPData>
	
	PROCEDURE GotFocus
		IF EMPTY(THIS.cErrorMsg)
		    IF PEMSTATUS(THISFORM, 'ClearMessage', 5)
		        THISFORM.ClearMessage()
		    ENDIF
		ELSE
		    THIS.ShowErrorMsg()
		ENDIF
	ENDPROC

	PROCEDURE InteractiveChange
		IF PEMSTATUS(THISFORM, 'NoteChange', 5)
		    THISFORM.NoteChange(.T.)
		ENDIF
		THIS.bItChanged = .T.
	ENDPROC

	PROCEDURE setbgcolor		&& Sets the B/G color for "E"rror, "W"arning or "N" ormal (the default)
		LPARAMETERS cType
		DO CASE
		CASE cType = 'E'
		    THIS.BackColor = RGB(255,210,210)       && Error Color
		CASE cType = 'W'
		    THIS.BackColor = RGB(255,255,190)       && Warning Color
		OTHERWISE
		    THIS.BackColor = RGB(255,255,255)       && Normal Color
		ENDCASE
	ENDPROC

	PROCEDURE showerrormsg		&& Display our error message
		IF PEMSTATUS(THISFORM, 'ShowMessage', 5)
		    THISFORM.ShowMessage(THIS.cErrorMsg, 'E', THIS)
		ELSE
		    WAIT WINDOW THIS.cErrorMsg
		ENDIF
	ENDPROC

	PROCEDURE Valid
		LOCAL nRetVal
		
		* Assume validation will be OK
		nRetVal = 1
		
		* Put your validation code here
		
		
		
		
		
		* Based on your code, you can call:
		*   THIS.SetBGColor(cLtr)
		* where cLtr = 'E'rror, 'W'arning or 'N'ormal
		* IF nRetVal = 0
		*     THIS.SetBGColor('E')
		* ELSE
		*     THIS.SetBGColor('N')
		*ENDIF
		
		* Done
		RETURN nRetVal
	ENDPROC

ENDDEFINE

DEFINE CLASS zbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove this objecct from memory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Command"
	DisabledForeColor = 83,80,68
	Height = 27
	Name = "zbutton"
	Width = 84
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
		
	ENDPROC

	PROCEDURE release		&& Remove this objecct from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE

DEFINE CLASS zcontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove this object from memory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 200
	Name = "zcontainer"
	Width = 200
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* Kill any objects we added
		LOCAL nX
		FOR nX = THIS.ControlCount TO 1 STEP -1
		    DO CASE
		    CASE ISNULL( THIS.Controls[nX] )
		        RELEASE THIS.Controls[nX]
		    CASE PEMSTATUS(THIS.Controls[nX], 'Release', 5)
		        THIS.Controls[nX].Release()
		    OTHERWISE
		        THIS.Controls[nX].Destroy()
		        RELEASE (THIS.Controls[nX].Name)
		    ENDCASE
		ENDFOR
		DODEFAULT()
		NODEFAULT
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
	ENDPROC

	PROCEDURE release		&& Remove this object from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE

DEFINE CLASS zcustom AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove our object from memory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "zcustom"
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* Kill any objects we added
		LOCAL nX
		FOR nX = THIS.ControlCount TO 1 STEP -1
		    DO CASE
		    CASE ISNULL( THIS.Controls[nX] )
		        RELEASE THIS.Controls[nX]
		    CASE PEMSTATUS(THIS.Controls[nX], 'Release', 5)
		        THIS.Controls[nX].Release()
		    OTHERWISE
		        THIS.Controls[nX].Destroy()
		        RELEASE (THIS.Controls[nX].Name)
		    ENDCASE
		ENDFOR
		DODEFAULT()
		NODEFAULT
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
	ENDPROC

	PROCEDURE release		&& Remove our object from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE

DEFINE CLASS zeditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove this object from memory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	DisabledForeColor = 83,80,68
	Height = 53
	Name = "zeditbox"
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="disabledforecolor" display="DisabledForeColor"/>
		<memberdata name="release" display="Release"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
	ENDPROC

	PROCEDURE release		&& Remove this object from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE

DEFINE CLASS zline AS line 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove this object from memory
	*</DefinedPropArrayMethod>

	Height = 17
	Name = "zline"
	Width = 100
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
	ENDPROC

	PROCEDURE release		&& Remove this object from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE

DEFINE CLASS ztextbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: release		&& Remove this object from memory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	DisabledForeColor = 83,80,68
	Height = 23
	Name = "ztextbox"
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="release" display="Release"/>
		<memberdata name="disabledforecolor" display="DisabledForeColor"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL aErrInfo[7], cMethName, cSys16, cCmd, oParent, bGotGlobal, ;
		  cAction, cHndlCmd, nChoice
		
		* Get the error info and define stuff about ourselves
		AERROR(aErrInfo)
		cMethName = THIS.Name + '.' + cMethod
		cSys16 = SYS(16)
		cCmd = MESSAGE(1)
		
		* First, do we have a parent?
		oParent = NULL
		IF PEMSTATUS(THIS, [Parent], 5) AND TYPE([THIS.Parent]) = [O] AND ;
		  PEMSTATUS(THIS.Parent, [Error], 5)
		    oParent = THIS.Parent
		ENDIF
		
		* Now, register the error if we have a global handler
		bGotGlobal = .F.
		IF TYPE('goError.Name') = 'C'
		    goError.RegisterError(nError, cMethName, nLine, @aErrInfo, cSys16, ;
		      THIS)
		    bGotGlobal = .T.
		ENDIF
		
		* Handle this error as best we can after assuming our return action
		cAction = 'RETURN'
		DO CASE
		
		* First, try the parent
		CASE NOT ISNULL(oParent)
		    cAction = oParent.Error(nError, cMethName, nLine)
		
		* Next, the global error handling object
		CASE bGotGlobal
		    cAction = goError.HandleError(nError, cMethName, nLine, @aErrInfo, ;
		      cSys16, THIS)
		
		* There may be some other global error handler.  So give it what it
		*   wants.  Caution: It may be called as a function or with a DO
		CASE NOT EMPTY( ON('ERROR') )
		    cHndlCmd = UPPER(ON('ERROR') )
		    cHndlCmd = STRTRAN( STRTRAN( STRTRAN( STRTRAN( STRTRAN( cHndlCmd, ;
		      'PROGRAM()', '"' + cMethName + '"'), ;
		      'ERROR()',   'nError'), ;
		      'LINENO()',  'nLine'), ;
		      'MESSAGE()', 'aErrInfo[2]'), ;
		      'SYS(2018)', 'aErrInfo[3]')
		    IF LEFT(cHndlCmd, 3) = [DO ]
		        &cHndlCmd
		    ELSE
		        cAction = &cHndlCmd
		    ENDIF
		OTHERWISE
		
		    * Nothing else left to do.  Ask if they want to Continue, Cancel or
		    *   get the debugger; this must only happen in test.  The
		    *   parameter MB_YESNOCANCEL = 3 + MB_ICONSTOP = 16 = 19
		    nChoice = MESSAGEBOX('Error #: ' + LTRIM(STR(nError)) + CHR(13) + ;
		      'Message: ' + aErrInfo[2] + CHR(13) + ;
		      'Line: ' + LTRIM(STR(nLine)) + CHR(13) + ;
		      'Code: ' + cCmd + CHR(13) + ;
		      'Method: ' + cMethName + CHR(13) + ;
		      'Object: ' + THIS.Name + CHR(13) + CHR(13) + ;
		      'Choose Yes to display the debugger, No to ' + ;
		      'Continue without the debugger, or Cancel to ' + ;
		      'cancel execution', 19, _VFP.Caption)
		
		    * If we're to debug, do it here and set for RETURN
		    DO CASE
		    CASE nChoice = 6            && IDYES
		        cAction = [RETURN]
		        DEBUG
		        SUSPEND
		    CASE nChoice = 7            && IDNO
		        cAction = [RETURN]
		    CASE nChoice = 2            && IDCANCEL
		        cAction = [CANCEL]
		    ENDCASE
		ENDCASE
		
		* Handle the return value but check the hierarchy first
		DO CASE
		CASE '.' $ cMethName
		    RETURN cAction              && Calling method
		CASE cAction = 'CLOSEFORM'
		    THISFORM.Release()
		CASE NOT EMPTY(cAction)         && RETURN, RETRY, CANCEL
		    &cAction                    && Do it
		ENDCASE
		RETURN                          && What else?
		
	ENDPROC

	PROCEDURE release		&& Remove this object from memory
		THIS.Destroy()
		RELEASE THIS
	ENDPROC

ENDDEFINE
